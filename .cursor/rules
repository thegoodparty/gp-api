---
description: Cursor rules for GP-API TypeScript/NestJS project. Enforce type safety, Prisma patterns, exception handling, and coding standards.
globs: ['**/*.ts', '**/*.js', '**/*.tsx', '**/*.jsx']
alwaysApply: true
---

# Cursor Rules for GP-API

## Rule 0: Type Safety

NEVER use the `any` or `unknown` types in new code. Always use proper TypeScript types:

- ✅ Good: `user: User`, `data: { id: string; name: string }`, `error: Error`
- ❌ Bad: `user: any`, `data: any`, `error: any`, `value: unknown`

For complex external API responses, create proper interfaces:

```typescript
interface ApiResponse {
  data: { id: string; name: string }
  status: 'success' | 'error'
}
```

For catch blocks, use `Error` type or create specific error types:

```typescript
try {
  // code
} catch (error: Error) {
  // handle error
}
```

For function parameters where the type is truly unknown, use generics or unions:

```typescript
function processData<T>(data: T): T {
  return data
}
// or
function handleValue(value: string | number | boolean): void {}
```

For external API responses that need validation, use proper type guards or validation libraries:

```typescript
function isApiResponse(data: unknown): data is ApiResponse {
  return typeof data === 'object' && data !== null && 'data' in data
}
```

Pre-existing `any` and `unknown` types have been marked with `// eslint-disable-next-line @typescript-eslint/no-explicit-any` and `// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment` respectively for gradual migration.

## Rule 1: Exception Handling

External service calls (e.g., Vercel) should be wrapped in try-catch and throw BadGateway on failure; DB updates have Prisma exception handling and should not be caught; use BadRequestExceptions for client request errors.

## Rule 2: Prisma Service Pattern

When creating or modifying Prisma model services:

1. **Use createPrismaBase pattern**: All Prisma model services MUST extend `createPrismaBase(MODELS.ModelName)`
   - Import: `import { createPrismaBase, MODELS } from 'src/prisma/util/prisma.util'`
   - Class declaration: `export class ServiceName extends createPrismaBase(MODELS.ModelName)`
   - Call `super()` in constructor if one exists
2. **Access Prisma models**: Use `this.model` to access the Prisma model instead of directly injecting PrismaService
   - ✅ Good: `this.model.create(args)`
   - ❌ Bad: `this.prisma.modelName.create(args)`
3. **Available methods**: The base class provides these methods automatically:
   - `findMany`, `findFirst`, `findFirstOrThrow`, `findUnique`, `findUniqueOrThrow`, `count`
   - Access the raw client with `this.client`
4. **Example pattern**:

```typescript
import { Injectable } from '@nestjs/common'
import { createPrismaBase, MODELS } from 'src/prisma/util/prisma.util'
import { Prisma } from '@prisma/client'
@Injectable()
export class MyModelService extends createPrismaBase(MODELS.MyModel) {
  constructor(
    // other dependencies
  ) {
    super()
  }
  customMethod() {
    return this.model.create({ data: {...} })
  }
}
```

5. **Service logic**: Keep services focused on data operations. Business logic should be in controllers.
   - ✅ Good: `createStatusLog(id, fromStatus, toStatus)`
   - ❌ Bad: `logStatusChangeIfNeeded(id, oldStatus, newStatus)` - the "if needed" logic belongs in controller

## Rule 3: Exception Handling Pattern

When choosing between different HTTP exception types:

1. **Use BadRequestException (400)** for client-side errors:
   - Invalid input data or parameters
   - Validation failures
   - Missing required fields
   - Malformed requests
   - Business logic violations caused by user input
   - ✅ Example: `throw new BadRequestException('Domain name is required')`
2. **Use BadGatewayException (502)** for external service failures:
   - Third-party API failures (Vercel, AWS, Stripe, etc.)
   - External service timeouts or connectivity issues
   - Upstream service errors that are not user-caused
   - Infrastructure/network problems
   - ✅ Example: `throw new BadGatewayException('Failed to register domain with Vercel')`
3. **Use ConflictException (409)** for resource conflicts:
   - Duplicate entries
   - Resource state conflicts
   - ✅ Example: `throw new ConflictException('Domain not available')`
4. **Use NotFoundException (404)** for missing resources:
   - Resource doesn't exist
   - ✅ Example: `throw new NotFoundException('Domain not found')`

### Try-Catch Block Pattern

- Only wrap external service calls in try-catch blocks, not database operations
- Database operations should rely on Prisma's built-in exception handling
- Handle external service failures separately from internal logic

```typescript
// ✅ Good
let externalResult
try {
  externalResult = await this.externalService.doSomething()
} catch (error) {
  throw new BadGatewayException('External service failed')
}
// Continue with database operations outside try-catch
await this.model.update(...)

// ❌ Bad - includes DB operations in try-catch
try {
  const result = await this.externalService.doSomething()
  await this.model.update(...)
} catch (error) {
  // This catches both external and DB errors
}
```

## Rule 4: Code Style

Do not add comments to code, ever.

## Rule 5: Strict Implementation Scope

CRITICAL REQUIREMENT:

- Only create or implement EXACTLY what the user explicitly requests
- Do NOT add any additional files, features, or functionality beyond the specific request

PROHIBITED:

- Creating controllers when only asked for a module
- Creating services when only asked for a module
- Creating DTOs, guards, or any other files not explicitly requested
- Adding imports or dependencies not explicitly requested
- Implementing CRUD operations or any logic not explicitly requested
- Creating directory structures beyond what's needed for the requested files
- Making assumptions about what the user "might want"

REQUIRED BEHAVIOR:

- If asked to create a module, create ONLY the module file
- If asked to create a service, create ONLY the service file
- Wait for explicit instructions before adding any additional functionality
- Ask for clarification if the scope is unclear rather than assuming

## Rule 6: Use Available Libraries

CRITICAL REQUIREMENT:

- Always attempt to use libraries that are listed in the `package.json` for relevant functionality
- Avoid implementing custom solutions when a library can provide the needed functionality

IMPLEMENTATION:

- Check the `package.json` for available libraries before implementing new functionality
- Use the library's documentation for the version `package-lock.json` specifies to integrate it effectively into the codebase

## Rule 7: NestJS Services Directory Structure

CRITICAL REQUIREMENT:

- Every `*.service.ts` file MUST reside in a `services/` subdirectory within its module folder
- This rule applies consistently across ALL modules in ANY NestJS application

EXPECTED STRUCTURE:

```
src/module-name/
  module-name.module.ts
  module-name.controller.ts
  services/
    module-name.service.ts
    other-service.service.ts
```

PROHIBITED:

- Placing service files directly in module root
- Creating service files outside a `services/` folder
- Having multiple `services/` folders per module
- Any exceptions or deviations from this pattern

## Rule 8: Use http-constants-ts for MIME Types

CRITICAL REQUIREMENT:

- Always use the `http-constants-ts` library for MIME type constants
- Avoid using string literals for MIME types in the codebase

IMPLEMENTATION:

- Import the necessary MIME type constants from `http-constants-ts`
- Replace any existing string literals representing MIME types with the corresponding constants from the library

## Rule 9: Consume Provided Documentation Links

CRITICAL REQUIREMENT:

- Always read and utilize documentation links provided by the user
- Ensure that the information from the links is accurately reflected in the code changes or responses

IMPLEMENTATION:

- Thoroughly review the content of any documentation links provided by the user
- Apply the information from the documentation to the task at hand, ensuring accuracy and relevance

## Rule 10: Mandatory Rule Compliance

CRITICAL REQUIREMENT:
ALL rules, both global and project-specific, MUST be followed with ZERO exceptions.

REQUIRED BEHAVIOR:

```javascript
// Rule compliance is MANDATORY
const beforeAnyAction = () => {
  checkAllGlobalRules()
  checkAllProjectRules()
  verifyExplicitPermissions()
  if (!allRulesFollowed || !explicitPermission) {
    HALT_IMMEDIATELY()
  }
}
```

VERIFICATION CHECKLIST:

1. ✓ Verify compliance with ALL global rules
2. ✓ Verify compliance with ALL project rules
3. ✓ Confirm EXPLICIT permission exists
4. ✓ Cross-reference against ALL rules
5. ✓ If ANY uncertainty exists, STOP

STRICTLY PROHIBITED:

- Creating ANY files without EXPLICIT permission
- Modifying ANY directories without EXPLICIT permission
- Ignoring or bypassing ANY rules
- Making assumptions about rule flexibility
- Proceeding with unclear rule compliance
- Creating exceptions to ANY rules

## Rule 11: No Redundant Application Prompts

- If the user has explicitly instructed you to make a change, DO NOT ask for confirmation or permission to apply it
- IMMEDIATELY proceed to apply the change as instructed
- Only ask for clarification if the instruction is ambiguous or incomplete

RATIONALE:

- Respects user intent and time
- Prevents unnecessary interruptions and frustration

## Rule 12: Ternary Expression Preference

When assigning a value or returning from a function based on a condition:

- **ALWAYS** use a ternary expression instead of an if-then-else statement when the result is a single value (assignment or return)
- **AVOID** using if-then-else statements for simple value selection or return

EXAMPLES:

**PREFER:**

```javascript
const result = condition ? valueIfTrue : valueIfFalse

return isValid ? successValue : errorValue
```

**AVOID:**

```javascript
let result
if (condition) {
  result = valueIfTrue
} else {
  result = valueIfFalse
}

if (isValid) {
  return successValue
} else {
  return errorValue
}
```

EXCEPTIONS:

- When the condition or values are very complex
- When you need to perform multiple operations in each branch
- When you need to handle more than two cases (use switch or if-else-if)

## Rule 13: No Redundant Variables for Direct Returns

- When writing or refactoring code, do NOT create a variable just to immediately return its value
- If a function/method call (async or sync) is the final result, return it directly
- Do NOT use the `await` keyword if you are simply returning the result of an async function call (i.e., use `return someAsyncFunction()` instead of `return await someAsyncFunction()`)
- Only assign to a variable if you need to use the value for additional logic before returning

EXAMPLES:

PREFER:

```typescript
return someAsyncFunction()
```

AVOID:

```typescript
const result = await someAsyncFunction()
return result
```

## Rule 14: Never Delete Existing Comments

CRITICAL REQUIREMENT:

- You MUST NOT delete, modify, or alter any comments that already exist in the codebase, regardless of their content, style, or location

REQUIRED BEHAVIOR:

- When editing code, you may add, update, or remove your own AI-generated comments (if allowed by other rules), but you MUST NOT touch any pre-existing comments
- If you encounter a scenario where a comment must be changed or removed, you MUST halt and request explicit user permission before proceeding

STRICTLY PROHIBITED:

- Deleting any comment that was present in the codebase before your edit
- Modifying the content of any existing comment
- Reformatting, moving, or altering the position of any existing comment
- Removing comments as part of code refactoring, cleanup, or formatting

## Rule 15: Git Command Output Format

CRITICAL REQUIREMENT:
All git commit commands MUST be output within a bash code block.

REQUIRED FORMAT:

```bash
git commit -a -m "commit message"
```

PROHIBITED:

- Outputting git commit commands without code block formatting
- Using any other code block language than 'bash'
- Outputting the command as plain text

EXAMPLES:
✅ CORRECT:

```bash
git commit -a -m "feat: add new feature"
```

❌ INCORRECT:
git commit -a -m "feat: add new feature"

```sh
git commit -a -m "feat: add new feature"
```

## Rule 16: Project Rule Application Requirements

CRITICAL REQUIREMENT:
All project-specific rules (rules in .cursor/rules/) MUST have alwaysApply set to true in their frontmatter.

REQUIRED FRONTMATTER FORMAT:

```yaml
---
description: [Rule description]
globs: [Optional glob patterns]
alwaysApply: true # This MUST be present and set to true
---
```

PROHIBITED:

- Creating project rules without alwaysApply: true
- Defaulting to rules that require explicit inclusion
- Omitting the alwaysApply field in frontmatter
- Setting alwaysApply to false for project rules

## Rule 17: Rule Creation Permission Requirements

CRITICAL REQUIREMENT:
DO NOT create any new .cursor/rules/\*.mdc files unless EXPLICITLY instructed to do so.

EXPLICIT PERMISSION MEANS:

- User specifically uses the word "create" in their request
- User specifically asks to "make a new rule file"
- User specifically asks to "add a rule file"

PROHIBITED:

- Creating rule files when only asked to "write" a rule
- Creating rule files when only asked to "describe" a rule
- Creating rule files when only asked to "explain" a rule
- Creating rule files proactively or preemptively
- Creating rule files without direct instruction

When asked to "write" a rule without explicit creation permission:

- Only output the rule content in the conversation
- Wait for explicit instruction to create the actual file

## Rule 18: File Deletion Requirements

When attempting to delete files:

REQUIRED STEPS:

1. ALWAYS verify file existence first:
   - Use `list_dir` to check directory contents
   - Use `file_search` to confirm exact path if needed
   - Use `grep_search` to verify file contents if relevant

2. DELETION HIERARCHY:
   - First attempt: Use `delete_file` tool with relative path
   - If failed: Use `delete_file` tool with absolute path
   - If still failed: Use terminal `rm` command as last resort

3. VERIFICATION:
   - MUST verify deletion success using `list_dir` afterward
   - MUST confirm to user that deletion was successful
   - MUST report any issues or failures clearly

PROHIBITED:

- Never assume file deletion succeeded without verification
- Never make multiple unsuccessful deletion attempts without changing approach
- Never leave files in an uncertain state

## Rule 19: Git Commit Flag Requirements

When providing git commit commands:

MUST INCLUDE:

- Always use the `-a` flag with git commit commands
- Format should be: `git commit -a -m "commit message"`

PROHIBITED:

- Never output a git commit command without the `-a` flag
- Do not use `git commit -m` alone

EXAMPLES:
✅ CORRECT:

```bash
git commit -a -m "feat: add new feature"
git commit -a -m "fix: resolve bug"
```

❌ INCORRECT:

```bash
git commit -m "feat: add new feature"
git commit -m "fix: resolve bug"
```

## Rule 20: Remove Code Completely

When removing or replacing code:

MUST DO:

- Delete code completely when it's no longer needed
- Remove all associated code that becomes unused as a result
- Never leave commented-out blocks of old code
- Check for and remove any imports that are no longer used

VERIFICATION STEPS:

1. Confirm the code is truly obsolete before removing
2. Use search tools to find any other code that might depend on it
3. Ensure tests still pass after complete removal
4. Remove any associated imports, comments, or dependencies
5. Verify the codebase is cleaner and more maintainable after the removal

## Rule 21: Follow SOLID Principles

When designing and implementing code:

SOLID PRINCIPLES:

- Single Responsibility: Each class/module should have only one reason to change
- Open/Closed: Classes/modules should be open for extension but closed for modification
- Liskov Substitution: Derived classes must be substitutable for their base classes
- Interface Segregation: Make fine-grained interfaces specific to clients
- Dependency Inversion: Depend on abstractions, not concretions

IMPLEMENTATION GUIDELINES:

1. Analyze each class/function to ensure it has a single, well-defined purpose
2. Design for extension through inheritance, interfaces, or composition
3. Maintain consistent behavior when extending or implementing base classes
4. Create specific, focused interfaces rather than large, general-purpose ones
5. Inject dependencies rather than creating them within classes

## Rule 22: Apply DRY Principle

When writing or modifying code:

DRY GUIDELINES:

- Abstract repeated code into reusable functions, classes, or modules
- Isolate concerns and responsibilities into separate units of code
- Identify and eliminate duplicate logic across the codebase
- Create shared utilities for common operations
- Use composition and inheritance appropriately to avoid duplication

IMPLEMENTATION STEPS:

1. Identify patterns or repeated logic in the code
2. Extract common functionality into well-named functions or classes
3. Consider creating utilities, hooks, or higher-order components for shared behavior
4. Ensure abstractions are at the right level (not too specific, not too general)
5. Use parameters and configuration to adapt shared code to different contexts

## Rule 23: Import/Export Verification

When modifying, deleting, or adding code that involves imports or exports:

MUST DO:

- Before removing any file, check for all imports of that file across the codebase
- Before removing any exported function, class, or variable, check for all imports of that specific export
- After renaming a file, update all imports that reference it
- When adding an import, verify that the imported path and exported items actually exist
- After changing an export, verify all files that import it still work correctly

VERIFICATION STEPS:

1. Use grep or codebase search to find all imports of the file you're modifying
2. Check each import to ensure it's still valid after your changes
3. For any import that's no longer valid, either update it or remove it
4. Pay special attention to utilities that might be widely used across the codebase
5. If adding a new import, double-check that the file and export exist

## Rule 24: Ensure HTTP methods decorated with @HttpCode(HttpStatus.NO_CONTENT) don't return response data

globs: ["**/*.controller.ts", "**/*.ts"]
alwaysApply: true

## HTTP 204 No Content Response Rule

#### Rule: No Response Data for HTTP 204

Methods decorated with `@HttpCode(HttpStatus.NO_CONTENT)` MUST NOT return any data.

REQUIRED BEHAVIOR:

- Use `await` instead of `return` for service calls in methods with `@HttpCode(HttpStatus.NO_CONTENT)`
- HTTP 204 responses indicate successful processing with no content body
- The method should execute the operation but not return any response data

EXAMPLES:

**CORRECT:**

```typescript
@Delete('resource/:id')
@HttpCode(HttpStatus.NO_CONTENT)
async deleteResource(@Param('id') id: string) {
  await this.service.delete(id)
}
```

**INCORRECT:**

```typescript
@Delete('resource/:id')
@HttpCode(HttpStatus.NO_CONTENT)
async deleteResource(@Param('id') id: string) {
  return this.service.delete(id) // ❌ Returns data with 204 status
}
```

VERIFICATION:

- Check all controller methods with `@HttpCode(HttpStatus.NO_CONTENT)`
- Ensure they use `await` for service calls instead of `return`
- Maintain HTTP specification compliance where 204 means "no content"

## General NestJS Patterns

- Follow established patterns in the codebase
- Use proper decorators and validation
- Keep controllers focused on HTTP concerns and business logic
- Keep services focused on data operations

# E2E Testing Patterns for GP-API

## File Organization

1. **Test file location**: Place test files alongside the feature they test:
   - ✅ Good: `src/authentication/tests/login.e2e.ts`
   - ✅ Good: `src/campaigns/tasks/tests/list-tasks.e2e.ts`
   - ❌ Bad: `e2e-tests/authentication/login.e2e.ts` (centralized location)

2. **Shared utilities**: All shared test utilities go in `e2e-tests/utils/`:
   - `e2e-tests/utils/auth.util.ts` - authentication helpers
   - `e2e-tests/utils/test-context.types.ts` - shared types
   - Additional utility files as needed

3. **Test fixtures**: Place test files and images in `e2e-tests/fixtures/`:
   - `e2e-tests/fixtures/test-image.png`
   - `e2e-tests/fixtures/test-file.txt`

## Test Structure

1. **Import order**:

```typescript
import { test, expect } from '@playwright/test'
import { HttpStatus } from '@nestjs/common'
import {
  registerUser,
  cleanupTestUser,
  generateRandomEmail,
  // ... other auth utils
} from '../../../e2e-tests/utils/auth.util'
import { TestInfoWithContext } from '../../../e2e-tests/utils/test-context.types'
```

2. **Test describe blocks**: Always use descriptive test.describe():

```typescript
test.describe('Feature - Operation', () => {
  // tests here
})
```

## Test Cleanup Pattern

**CRITICAL**: Always clean up test users to prevent database pollution.

### Pattern 1: Using TestContext (Recommended for tests that create users in beforeEach)

```typescript
test.beforeEach(async ({ request }, testInfo) => {
  const testUserEmail = generateRandomEmail()
  const firstName = generateRandomName()
  const lastName = generateRandomName()

  const result = await registerUser(request, {
    firstName,
    lastName,
    email: testUserEmail,
    password: 'password123',
    phone: '5555555555',
    zip: '12345-1234',
    signUpMode: 'candidate',
  })

  ;(testInfo as TestInfoWithContext).testContext = {
    testUser: {
      userId: result.user.id,
      authToken: result.token,
    },
    testUserEmail,
  }
})

test.afterEach(async ({ request }, testInfo) => {
  const testContext = (testInfo as TestInfoWithContext).testContext

  if (testContext) {
    await cleanupTestUser(request, testContext.testUser)
  }
})
```

### Pattern 2: Using test-scoped variables (For tests that create users per test)

```typescript
test.describe('Feature', () => {
  let testUserId: number | undefined
  let authToken: string | undefined

  test.afterEach(async ({ request }) => {
    if (testUserId && authToken) {
      await deleteUser(request, testUserId, authToken)
      testUserId = undefined
      authToken = undefined
    }
  })

  test('should do something', async ({ request }) => {
    const registerResponse = await registerUser(request, { ... })
    testUserId = registerResponse.user.id
    authToken = registerResponse.token

    // test logic
  })
})
```

### Pattern 3: Manual cleanup in test (For tests with multiple users)

```typescript
test('should handle multiple users', async ({ request }) => {
  const user1Response = await registerUser(request, { ... })
  const user2Response = await registerUser(request, { ... })

  try {
    // test logic
  } finally {
    await deleteUser(request, user1Response.user.id, user1Response.token)
    await deleteUser(request, user2Response.user.id, user2Response.token)
  }
})
```

## Type Usage

1. **Use Prisma types for database models**:

```typescript
import { Prisma } from '@prisma/client'

type WebsiteWithDomain = Prisma.WebsiteGetPayload<{
  include: {
    domain: true
  }
}>

const website = (await response.json()) as WebsiteWithDomain
```

2. **Use schema output types for API responses**:

```typescript
import { ReadUserOutput } from '../schemas/ReadUserOutput.schema'

const body = (await response.json()) as ReadUserOutput
```

3. **Define response types in auth.util.ts**:

```typescript
export interface LoginResponse {
  token: string
  user: {
    id: number
    email: string
    firstName: string
    lastName: string
    roles: string[]
    hasPassword: boolean
    password?: undefined
  }
}
```

4. **Use feature-specific types from the feature being tested**:

```typescript
import { CampaignTask } from '../campaignTasks.types'

const tasks = (await response.json()) as CampaignTask[]
```

## Fake Data Generation

**Always use Faker** for generating test data via the auth.util helpers:

```typescript
import {
  generateRandomEmail,
  generateRandomName,
  generateRandomPassword,
} from '../../../e2e-tests/utils/auth.util'

const email = generateRandomEmail() // test-xxxxx@goodparty.org
const firstName = generateRandomName() // realistic first name
const lastName = generateRandomName() // realistic last name
const password = generateRandomPassword() // secure random password
```

For other random data needs:

```typescript
const vanityPath = `test-path-${Date.now()}`
const randomWebsite = `https://${Math.random().toString(36).substring(7)}.com`
```

## HTTP Status Codes

Always use `HttpStatus` enum from `@nestjs/common`:

```typescript
import { HttpStatus } from '@nestjs/common'

expect(response.status()).toBe(HttpStatus.OK) // 200
expect(response.status()).toBe(HttpStatus.CREATED) // 201
expect(response.status()).toBe(HttpStatus.NO_CONTENT) // 204
expect(response.status()).toBe(HttpStatus.BAD_REQUEST) // 400
expect(response.status()).toBe(HttpStatus.UNAUTHORIZED) // 401
expect(response.status()).toBe(HttpStatus.FORBIDDEN) // 403
expect(response.status()).toBe(HttpStatus.NOT_FOUND) // 404
expect(response.status()).toBe(HttpStatus.CONFLICT) // 409
```

## Environment Variables and Test Skipping

Use environment variables for existing test users (candidate, admin):

```typescript
test.describe('Feature requiring existing user', () => {
  const candidateEmail = process.env.CANDIDATE_EMAIL
  const candidatePassword = process.env.CANDIDATE_PASSWORD

  test.beforeAll(() => {
    test.skip(
      !candidateEmail || !candidatePassword,
      'Candidate credentials not configured',
    )
  })

  test('should do something', async ({ request }) => {
    const { token } = await loginUser(
      request,
      candidateEmail!,
      candidatePassword!,
    )
    // test logic
  })
})
```

Or skip individual tests conditionally:

```typescript
test('should work with data', async ({ request }) => {
  const data = await getTestData(request)

  if (!data || data.length === 0) {
    test.skip()
    return
  }

  // test logic
})
```

## File Uploads

For tests that require file uploads:

```typescript
import * as fs from 'fs'
import * as path from 'path'

const imagePath = path.join(
  __dirname,
  '../../../e2e-tests/fixtures/test-image.png',
)
const imageBuffer = fs.readFileSync(imagePath)

const response = await request.post('/v1/endpoint', {
  headers: {
    Authorization: `Bearer ${authToken}`,
  },
  multipart: {
    file: {
      name: 'test-image.png',
      mimeType: 'image/png',
      buffer: imageBuffer,
    },
    'field[name]': 'value',
  },
})
```

## Authentication Headers

Use consistent Bearer token format:

```typescript
const response = await request.get('/v1/endpoint', {
  headers: {
    Authorization: `Bearer ${authToken}`,
  },
})
```

## Error Response Handling

Check for failure responses with helpful debugging:

```typescript
const response = await request.post('/v1/endpoint', {
  data: { ... },
})

if (!response.ok()) {
  console.log('Request failed:', await response.text())
}
expect(response.status()).toBe(HttpStatus.CREATED)
```

## Assertion Patterns

1. **Basic status checks**:

```typescript
expect(response.status()).toBe(HttpStatus.OK)
expect(response.ok()).toBeTruthy()
```

2. **Response body checks**:

```typescript
const body = await response.json()
expect(body).toHaveProperty('id')
expect(body.email).toBe(testEmail)
expect(body.password).toBeUndefined() // never return passwords
```

3. **Array validations**:

```typescript
const items = (await response.json()) as Item[]
expect(Array.isArray(items)).toBe(true)
expect(items.length).toBeGreaterThan(0)

items.forEach((item) => {
  expect(item).toHaveProperty('id')
  expect(typeof item.name).toBe('string')
})
```

4. **Pattern matching**:

```typescript
expect(body.avatar).toMatch(
  /^https:\/\/assets(-dev|-qa)?\.goodparty\.org\/uploads\/.+\.(png|jpg|jpeg)$/,
)
```

5. **Multiple possible values**:

```typescript
expect([200, 404]).toContain(response.status())
```

## Test Data Isolation

- Each test should be independent and not rely on other tests
- Use `beforeEach` to set up fresh data for each test
- Use `afterEach` to clean up test data
- Don't share mutable state between tests
- Use `test.describe` blocks to group related tests with shared setup/teardown

## Common Pitfalls to Avoid

1. ❌ Don't forget to clean up test users
2. ❌ Don't use hardcoded status codes (use HttpStatus enum)
3. ❌ Don't use hardcoded test data (use faker utilities)
4. ❌ Don't define types inline when they exist in Prisma or schema files
5. ❌ Don't place shared utilities in individual test files
6. ❌ Don't forget to check for environment variables before using them
7. ❌ Don't create centralized test files (keep them near the features they test)
